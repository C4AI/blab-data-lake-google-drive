#!/usr/bin/env python3
"""A module that interacts with Google Drive API."""

from __future__ import annotations

from dateutil import parser as timestamp_parser
from dataclasses import dataclass, field
from datetime import datetime
from google.oauth2 import service_account
from googleapiclient.http import MediaIoBaseDownload
from googleapiclient.discovery import build, Resource
from overrides import overrides
from structlog import getLogger


_logger = getLogger(__name__)


_DEFAULT_PAGE_SIZE = 100
_FILE_FIELDS = ', '.join(['id', 'name', 'parents', 'kind', 'mimeType',
                         'webViewLink', 'md5Checksum', 'size', 'createdTime',
                          'modifiedTime', 'lastModifyingUser',
                          'headRevisionId', 'iconLink',
                          ])


@dataclass
class RemoteFile:
    """Represents a regular file or a directory stored on Google Drive."""

    name: str
    """File name (without directory)"""

    id: str
    """File id (generated by Google Drive)"""

    mime_type: str
    """MIME type"""

    created_time: datetime
    """Creation timestamp"""

    modified_time: datetime
    """Last modification timestamp"""

    modified_by: str
    """Name of the user who made the last change"""

    web_url: str
    """URL to access the file on a browser"""

    icon_url: str
    """URL of the file icon (does not require authentication)"""

    parent: RemoteDirectory | None
    """Parent directory"""

    def print_tree(self, _pfx: list[bool] | None = None) -> None:
        """Print the tree file names to standard output (for debugging)."""
        if _pfx is None:
            _pfx = []
        for i, p in enumerate(_pfx[:-1]):
            print(' ┃ ' if p else '   ', end=' ')
        if _pfx:
            print(' ┠─' if _pfx[-1] else ' ┖─', end=' ')
        print(self.name)

    def download(self, service: Resource, file_name: str) -> bool:
        """Download the file.

        Args:
            service: Google Drive service
                (see :attr:`GoogleDriveService.service`)
            file_name: local file name to store the contents

        Returns:
            whether the download completed successfully
        """
        log = _logger.bind(id=self.id, name=self.name, local_name=file_name)
        log.info('downloading file')
        with open(file_name, 'wb') as fd:
            request = service.files().get_media(
                fileId=self.id,
            )
            downloader = MediaIoBaseDownload(fd, request)
            completed = False
            while not completed:
                status, completed = downloader.next_chunk()
        return True


@dataclass
class RemoteDirectory(RemoteFile):
    """Represents a directory stored on Google Drive."""

    children: list[RemoteFile] = field(default_factory=list)
    """Subdirectories and regular files in this directory"""

    is_root: bool = False
    """Whether this directory is the root specified in the settings
        (not necessarily the root on Google Drive)"""

    def _fill_children(self, service: Resource,
                       gd_config: dict[str, str]) -> None:
        q_items = ['not trashed']
        if self.id:
            q_items.append(f"'{self.id}' in parents")
        q = ' and '.join(q_items)
        shared_drive_id = gd_config.get('SharedDriveId', None)
        params = dict(
            supportsAllDrives=bool(shared_drive_id),
            includeItemsFromAllDrives=bool(shared_drive_id),
            driveId=shared_drive_id or None,
            corpora='drive' if shared_drive_id else 'user',
            pageSize=int(gd_config.get('PageSize', None) or
                         _DEFAULT_PAGE_SIZE),
            fields=f'nextPageToken, files({_FILE_FIELDS})',
            orderBy='folder, name',
            q=q
        )
        page_token = None
        children = []
        page = 0
        log = _logger.bind(id=self.id)
        while page_token is not None or page == 0:
            request = service.files().list(
                pageToken=page_token,
                **params
            )
            log.debug('requesting directory', page=page)
            results = request.execute()
            children += results['files']
            page_token = results.get('nextPageToken', None)
            page += 1
        for f in children:
            metadata = [f['name'], f['id'], f['mimeType'],
                        timestamp_parser.parse(f['createdTime']),
                        timestamp_parser.parse(f['modifiedTime']),
                        f['lastModifyingUser']['displayName'],
                        f['webViewLink'], f['iconLink'],
                        self,
                        ]
            node: RemoteFile
            if f['mimeType'] == 'application/vnd.google-apps.folder':
                node = RemoteDirectory(*metadata)
                node._fill_children(service, gd_config)
            else:
                file_metadata = [
                    int(s) if (s := f.get('size', None)) is not None else None,
                    f.get('md5Checksum', None),
                    f.get('headRevisionId', None),
                ]
                node = RemoteRegularFile(*metadata, *file_metadata)
            self.children.append(node)

    @classmethod
    def get_tree(cls, service: Resource, gd_config: dict[str, str]
                 ) -> RemoteDirectory:
        """Fetch and return the directory tree from Google Drive.

        There is no depth limit.

        Args:
            service: Google Drive service
                (see :attr:`GoogleDriveService.service`)
            gd_config: configuration parameters

        Returns:
            an object representing the root directory defined
            by the ``SubTreeRootId`` field of :paramref:`gd_config`.
        """
        this_id = gd_config.get('SubTreeRootId', None) or \
            gd_config.get('SharedDriveId', None)
        shared_drive_id = gd_config.get('SharedDriveId', None)
        if this_id:
            request = service.files().get(
                fileId=this_id,
                supportsAllDrives=bool(shared_drive_id),
                fields=_FILE_FIELDS,
            )
            _logger.debug('requesting root directory', id=this_id)
            f = request.execute()
            metadata = [f['name'], f['id'], f['mimeType'],
                        timestamp_parser.parse(f['createdTime']),
                        timestamp_parser.parse(f['modifiedTime']),
                        f['lastModifyingUser']['displayName'],
                        f['webViewLink'], f['iconLink'],
                        None,
                        ]
        else:
            metadata = ['', None, None, None, None, None, None]
        root = RemoteDirectory(*metadata, is_root=True)  # type: ignore
        root._fill_children(service, gd_config)
        return root

    def flatten(self) -> dict[str, RemoteFile]:
        """Convert tree to a flat dictionary.

        Returns:
            a flat dictionary where files are mapped by their ids
        """
        d: dict[str, RemoteFile] = {self.id: self}
        for c in self.children:
            d.update(c.flatten() if isinstance(c, RemoteDirectory)
                     else {c.id: c})
        return d

    @overrides
    def print_tree(self, _pfx: list[bool] | None = None) -> None:
        super().print_tree(_pfx)
        if _pfx is None:
            _pfx = []
        for child in self.children[:-1]:
            child.print_tree(_pfx + [True])
        if self.children:
            self.children[-1].print_tree(_pfx + [False])


@dataclass
class RemoteRegularFile(RemoteFile):
    """Represents a regular file stored on Google Drive."""

    size: int
    """File size in bytes."""

    md5_checksum: str
    """File hash"""

    head_revision_id: str
    """Current version id (generated by Google Drive)"""

    @property
    def local_name(self) -> str:
        """Local file name (without path).

        Returns:
            Local file name
        """
        return self.id + \
            '_' + (self.head_revision_id or '') + \
            '_' + (self.md5_checksum or '')

    @property
    def is_google_workspace_file(self) -> bool:
        """Whether this is a Google Workspace file.

        Returns:
            ``True`` if and only if the MIME type starts
            with ``application/vnd.google-apps``
        """
        return self.mime_type.startswith('application/vnd.google-apps')


class GoogleDriveService:
    """A class that wraps Google Drive API consumer to get the directory tree.

    This class provides a method that obtains the directory tree
    from a Google Drive directory or shared drive.
    """

    def __init__(self, gd_config: dict[str, str]):
        """
        Args:
            gd_config: service configuration

        For a description of the expected keys and values of `gd_config`,
        see the section ``GoogleDrive`` in
        :download:`the documentation <../README_CONFIG.md>`.
        """  # noqa:D205,D400
        self.gd_config = gd_config
        """Configuration parameters"""

        self.service = self.__get_service()
        """Google Drive service."""

    def __get_service(self) -> Resource:
        scopes = ['https://www.googleapis.com/auth/drive']
        cred = service_account.Credentials.from_service_account_file(
            self.gd_config['ServiceAccountKeyFileName'], scopes=scopes)
        s = build('drive', 'v3', credentials=cred, cache_discovery=False)
        return s

    def get_tree(self) -> RemoteDirectory:
        """Fetch and return the directory tree from Google Drive.

        There is no depth limit.

        Returns:
            an object representing the root directory defined
            by the ``SubTreeRootId`` field of :attr:`gd_config`.
        """
        return RemoteDirectory.get_tree(self.service, self.gd_config)

    def download_file(self, file: RemoteRegularFile, output_file: str) -> None:
        """Download a file from Google Drive.

        Args:
            file: the file to download
            output_file: local file where the contents will be saved
        """
        file.download(self.service, output_file)
